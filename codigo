# ======================================
# Segmentación por Clustering (K-means en RGB)
# ======================================

import cv2
import numpy as np
import matplotlib.pyplot as plt
import os, zipfile, glob, re
import pandas as pd
from pathlib import Path
from sklearn.metrics import f1_score
from google.colab import files

# --- Subir archivos ---
print("Sube Imagenes.zip")
imgs_uploaded = files.upload()
print("Sube Segmentacion Ideal.zip")
gt_uploaded = files.upload()

# --- Extraer ZIPs ---
BASE = Path("/content")
IMG_DIR = BASE / "Imagenes"
GT_DIR  = BASE / "SegmentacionIdeal"

!rm -rf $IMG_DIR $GT_DIR
with zipfile.ZipFile(list(imgs_uploaded.keys())[0], 'r') as z:
    z.extractall(IMG_DIR)
with zipfile.ZipFile(list(gt_uploaded.keys())[0], 'r') as z:
    z.extractall(GT_DIR)

def list_images(folder):
    exts = ("*.png","*.jpg","*.jpeg","*.bmp","*.tif","*.tiff")
    files = []
    for e in exts:
        files.extend(glob.glob(str(Path(folder)/"**"/e), recursive=True))
    return sorted(files)

img_files = list_images(IMG_DIR)
gt_files  = list_images(GT_DIR)

print("Imágenes encontradas:", len(img_files))
print("GT encontradas:", len(gt_files))

# --- Normalizar IDs ---
def extract_isic_id(path):
    m = re.search(r'(isic[_-]?\d+)', Path(path).stem, flags=re.I)
    return m.group(1).lower() if m else Path(path).stem.lower()

gt_index = {extract_isic_id(p): p for p in gt_files}

# --- Función de segmentación con K-means ---
def kmeans_segmentation(img_bgr, K=2):
    h, w, c = img_bgr.shape
    Z = img_bgr.reshape((-1,3))
    Z = np.float32(Z)

    # Criterios de parada
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 20, 1.0)

    # Aplicar K-means
    _, labels, centers = cv2.kmeans(Z, K, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)

    # Elegir el cluster más oscuro (menor promedio de intensidad)
    centers_intensity = np.mean(centers, axis=1)
    darkest_cluster = np.argmin(centers_intensity)

    # Máscara binaria
    mask = (labels.flatten() == darkest_cluster).astype(np.uint8) * 255
    mask = mask.reshape((h,w))

    # Morfología
    kernel = np.ones((5,5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

    # Tomar el componente más grande
    num_labels, labels_cc, stats, _ = cv2.connectedComponentsWithStats(mask, connectivity=8)
    if num_labels > 1:
        largest = 1 + np.argmax(stats[1:, cv2.CC_STAT_AREA])
        mask = np.where(labels_cc == largest, 255, 0).astype(np.uint8)

    return mask

# --- Segmentación + F1 ---
results = []
MASKS_DIR = BASE / "Mascaras_KMeans"
MASKS_DIR.mkdir(exist_ok=True)

for img_path in img_files:
    img_id = Path(img_path).stem
    key    = extract_isic_id(img_path)
    img    = cv2.imread(img_path)

    mask = kmeans_segmentation(img, K=2)
    cv2.imwrite(str(MASKS_DIR / f"{img_id}_mask.png"), mask)

    gt_path = gt_index.get(key, None)
    if gt_path:
        gt = cv2.imread(gt_path, 0)
        gt = cv2.threshold(gt, 127, 255, cv2.THRESH_BINARY)[1]
        f1 = f1_score(gt.flatten()//255, mask.flatten()//255, average='binary')
    else:
        f1 = np.nan

    if np.isnan(f1):
        obs = "Sin GT para comparar"
    elif f1 > 0.85:
        obs = "Segmentación buena"
    elif f1 > 0.65:
        obs = "Segmentación aceptable"
    else:
        obs = "Segmentación deficiente"

    results.append((img_id, f1, obs))

# --- Estadísticas ---
scores = [r[1] for r in results if pd.notna(r[1])]
avg = np.mean(scores) if len(scores) else np.nan
std = np.std(scores) if len(scores) else np.nan

df = pd.DataFrame(results, columns=["Imagen ID", "F1 Score", "Observaciones"])
df.loc[len(df)] = ["PROMEDIO", avg, "-"]
df.loc[len(df)] = ["DESV. ESTÁNDAR", std, "-"]

print(df)
df.to_csv("/content/resultados_f1_kmeans.csv", index=False)

# --- Mostrar imágenes segmentadas ---
for img_path in img_files:
    img_id = Path(img_path).stem
    img = cv2.imread(img_path)
    mask = kmeans_segmentation(img, K=2)

    plt.figure(figsize=(12,5))
    plt.subplot(1,2,1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title(f"Original - {img_id}")
    plt.axis("off")

    plt.subplot(1,2,2)
    plt.imshow(mask, cmap="gray")
    plt.title("Segmentada (K-means en RGB)")
    plt.axis("off")

    plt.show()
